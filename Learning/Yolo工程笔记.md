数据：

session：{'uid': 用户的id, 'name': 用户的名字}

## Date: 24-4-4

1. 表设计
   - User表
   - DetectSet表
   - OriginImg表
2. 



## Date: 24-4-5

1. 用户登录/注册

   - 用户注册界面

     1. 确认密码，密码使用md5加密，创建简单的函数进行了封装，函数效果为传入字符串并返回该字符串的md5加密后字符串，其中hashlib调用的是django.settings文件中自带的key

        ;

        ![image-20240405095358694](pic_yolo/image-20240405095358694.png)

     2. 密码使用PasswordInput以隐藏密码, 因为继承了自定义类BootstrapModelForm，pwd的输入时会显示密码，所以此处为pwd框切换成PasswordInput模式以隐藏密码

     ![image-20240405094858775](pic_yolo/image-20240405094858775.png)

     3. 钩子函数：

        - 用户名钩子：返回名字监测用户名是否在表中存在，若存在则返回用户已存在的错误到页面上
        - 密码钩子：调用自定义的md5函数为密码加密
        - 重复密码钩子：md5加密的同时与上面的密码进行比较，若不同则返回错误

     4. 注册页面：

        由modelform自动生成输入框，并通过自定义的父类BootStrapModelForm为其添加样式，后续的输入框基本由此方式渲染，下方增加span标签的错误信息，如果返回错误时在此处显示，同时使用position悬浮让其在返回错误信息时确保不会改变输入框页面布局

     5. ajax请求：

        注册使用ajax请求达到在不刷新页面的情况下能够返回错误信息，其中ajax以post的请求把表单信息发送到当前的url，在当前的url函数中遇到post请求将会用modelform的方法验证表单信息，正确则保存并返回True到ajax，错误则返回Flase的同时返回错误信息，ajax获取页面信息后将错误信息添加到页面中

     

   - 用户注册函数

   - 用户登录界面

     新建User的modelform表，界面输入框与错误显示设计与前面所提相同

   - 用户登录函数

     使用form表单发送post请求的方法，登录后会验证用户是否在用户表中存在，若不存在会返回错误在输入框下方，若存在则发放cookie并添加session在数据库中，其中保存在session中的数据为字典'info'，内部的值为'uid'和'name'，以传递用户的id和名字

   - 用户登录中间件

     创建中间件Check_Cookie，在发送request请求的时候添加检查cookie的函数，如果登录成功后浏览器保存有cookie对应的session则可以访问网页，如果未登录，即没有cookie或者无cookie对应的session时访问其他网页都会跳转回登录界面，只有登录和注册界面能够进入。

     在这个中间件中不需要设置response

     ![image-20240405122440472](pic_yolo/image-20240405122440472.png)

2. utils/BootstrapForm创建

3. yolo/main首页

   登录后进入首页，同时会将session中保存的用户信息传递给页面渲染，其中保存的信息用来新建个人的监测图片/视频集合，以及在页面的右上角显示为个人的信息

4. 上传图片

   - 选择图片集界面：

     上面

   - 新建图片集：

     新建图片集时只需要在下方输入集合名，用ajax传递请求的数据包括输入的集合名，集合的类型'img'以及当前的用户id，在函数中对集合名进行查询是否已存在，若不存在则创建类型为img切所属用户为当前用户的数据成功并跳转到为这个集合添加图片的界面，若存在则返回错误信息在输入框下面，并提示已存在可以在上面的选择框中选择该图片集或重新创建

5. select-option类

   封装类select-option，输入集合的类型和集合的所属人，在内部获取相关类型的所有集合，格式化把这些集合名都分别创建为一个select的option选项的html字段，输出所有这些字段到html的select标签中显示，即可做到动态获取特定人的特定类型的所有目标在选项框中显示，并且每个选项框的value值都是相应的集合在数据库中的id，方便后续操作

   如果没有找到对应的数据，则会返回'空'选项在选项框



## Date: 24-4-7

1. 修改导航页面显示当前用户

   在'layout.html'这个母版html中传入当前的session信息，在右上角显示当前的用户名

2. 前往图片集

   获取yolo/main的弹窗1中的select选择框，选择框中每个选项的值对应着图片集的id，获取其中的值，并前往/yolo/set/获取值/img，的页面，该页面是id为获取值的图片集。同样创建新图片集后会用相同的方法前往该图片集页面

3. 上传图片

   再input标签中添加multiple的属性，达到能一次性上传多个文件的效果，选择文件点击新增图片的按钮后，通过post的方法将图片集合与一个隐藏的input标签中的图片集名字传递给新增图片的url。

   在新增图片的url中会组建图片地址在media/img_set/用户id_图片集名字/，如果不存在这个文件夹则通过makedir的方法创建文件夹（对于第一次新增图片的用户），随后将图片存入这个文件夹，并保存图片名与图片地址在数据库中的OriginImg表中以待后面使用。为防止用户多次新增图片在数据库中，在数据库存入图片地址时会检测表中是否已存在这个图片，如果存在则跳过。同时考虑到不同的集合里面可能出现同一张图片，这种情况是需要保存多个表中数据的，所以检测是否存在的条件中不仅需要图片名还需要图片所属的集合id。

4.  图片显示

   在utils/创建类ImgList来绘制图片在页面中的显示。显示图片用bootstrap中的卡片组，每一排放四个卡片组，用dispaly: flex属性来规划。其中的图片用类img-fluid 和样式object-fit: cover来确保图片在其位置上正比例缩放的填充图片框，然后用height:200px固定卡片中的图片高度为200px，以此达到更好的视图效果。完成这个类后在渲染函数中示例化并执行这个类中的html语句生成函数，将生成的html传入html页面即可

   这个类的主要效果是传入queryset语句，即查找到的所有目标，再通过其中的html函数返回查找的这些目标在页面中展示的html语句。

5. 图片编辑

   在创建图片时增加一个隐藏的checkbox，在点击图片集上面的编辑按钮时checkbox才会显示出来。同时在创建图片卡片时为上面的元素增加了一个edit_opacity的class，用来调整透明度，初始透明度为1但在点击编辑按钮时会变为0.5，表示当前状态为编辑状态，取消或者删除后会变为原透明度，表示现在时正常预览模式。

6. 图片删除

   通过点击编辑按钮显示出的勾选框，为他们都赋予一个img_checkbox的class，选中完要删除的图片后点击删除按钮将会通过这个class对每个checkbox的选择框进行判断，如果时选中的则将该图片的id加入到js中的全局变量列表中（此图片id由checkbox的input中的data-img-id属性获取）。点击删除后同时会出现一个是否删除的警告弹窗进行二次确认，如果再次确认删除则将该要删除的id列表通过ajax的方法传输到删除函数中进行删除，并返回删除成功弹窗并刷新页面重新渲染当前该集合里的图片。



## Date: 24-4-8

1. 继续完成图片删除功能

   - 修改了将图片相对地址保存到数据库的操作，如果路径最前面有一个'/'在Unix中表示绝对路径，这会导致后面的os.path.join的方法无法正常拼接两段路径，于是删除了保存路径创建时前面的/

     > 图片回收站？

   - 添加删除按钮检测：在未选择目标时点删除会提示请选择删除的图片弹窗

2. 增加OriginImg表中属性is_detect

   用来在图片集中显示该图片是否已经监测，以及作为标记防止多次监测同一张图片浪费计算机算力



## Date: 24-4-9

1. 添加开始监测按钮

   点击开始监测后会弹出是否检测好自己的图片集是否已确认以及是否确认开始检测的提示弹窗，点击确认后会关闭弹窗，将开始检测的按钮改变为正在检测，并检测页面上会把其他标签均降低透明度并为可以点击互动的地方都设置为不可选中，以此表示正在检测并且防止用户点击其他地方触发互动引发错误。

   在显示正在监测时，会使用ajax请求把图片集数据发送给后台的yolo函数进行监测，当监测完成将数据保存好后会返回指令，收到该指令后按钮会改变为监测完成，并在上方添加一段正在跳转的小字，该状态持续两秒后会跳转到监测结果的地址

2. 修改：生成集合的文件名

   从在要使用时获取session中的id与post请求中的文件名再组装成文件，修改为在models.py的表定义中增加组合文件名的函数，使用时只需找到该行并执行该函数，减少了操作

3. 创建表PredictImg

   用来放置预测后的图片集

   有两个外键分别连接了原图与图片集

   ```py
   class PredictedImg(models.Model):
       name = models.CharField(verbose_name='图片名', max_length=128)
       folder_name = models.ForeignKey(verbose_name='集合名', to=DetectSet, on_delete=models.CASCADE)
       img_path = models.CharField(verbose_name='图片地址', max_length=256)
       oring_img = models.ForeignKey(verbose_name='原图', to=OriginImg, on_delete=models.CASCADE)
       detect_info = models.JSONField(verbose_name='监测信息')
   ```

4. 封装img_predict类，完成图片监测与保存图片数据在本地和数据库的操作（施工中）



## Date: 24-4-11 (倒计时7)

1. 继续完成img_predict类封装

   ImgPredict函数封装作用：输入图片集合的id，将会在后台进行图片的目标预测，并将预测的数据信息以JSON的格式存入数据库

   具体实现方法如下：

   内置预训练文件'yolov8s.pt'作为预测模型，由于yolov8s.pt是以coco2017为训练集的，需要同时准备coco2017的监测列表。

   文件方面，传入图片集的id后根据图片集数据库中的信息，在该图片集所在的文件夹新建predicted文件夹用来放置预测后的文件。随后根据图片集在OriginImg表中获取所有的未监测的该图片集的原图信息，使用字典列表的方法存储每个原图的id，名字，图片地址。然后对该列表for循环，为每张图片单独进行预测，对图片监测框绘制完后存入上面提到的predicted文件夹中，再进行下一个图片的操作，直到全部完成

   数据库方面，在每个循环中本地存储完图片文件后将进行数据库信息的存储，使用boxes.cls获取每个监测框监测出来的物品类型，使用boxes.xyxy获取每个监测框的位置，将他们存入字典作为预测信息转为JSON格式存入数据库，方便后续查询操作。同时需要存储的是与原图相同的图片名字、文件地址、与该图片关联的图片集id（外键）以及与该图片关联的原图id（外键）。最后将原图表中的是否已监测数据更改为1表示该原图已进行监测，避免下次在该图片集增加图片再监测时重复监测该图片，减少计算机操作。
   
2. 监测图集页面编写（施工中）



## Date: 24-4-12 (倒计时6)

1. 监测图集页面编写（施工中）

   - 添加自定义封装的Pagination类进行翻页

   - 在上方添加一个一排最多为五张图片的缩略图列表，为这个列表添加刚才编写的翻页组建，达到翻页获取所有缩略图的效果。为这些缩略图添加a标签，但点击他们的时候会通过jQuery的方法切换下面的监测数据结果，将原图、监测图以及监测数据的标签都替换成对应图片的地址数据。同时翻页由于是通过GET方法实现的，每次翻页会刷新页面，所以下面的单张图片详细监测结果区块的初始值定为该页面下第一张图片的数据，每次翻页都会重置。

   - >  今日问题，在JS接收DJANGO用模板方法传递的字典列表时，需要通过''将其括起来，但括起来后变成了字符串，其字符串信息中的`'`变成了`&#x27;`，导致一些将他转换成正常字典列表的方法无法使用，要如何才能正常把他转化为正常的字典列表使得能够循环获取数据

     加班解决：在Django向HTML传入数据时先转换成JSON的格式，再在jQuery中将JSON格式转换成字典格式，转换方式为

     ```js
     JSON.parse('{{ predict_list.3.json_info_list|escapejs }}')
     // 注意后面的|escapejs
     ```

   - 将总监测数据传入js中在页面里绘制成图

     由于是使用detect_info的JSON字段存储进数据库，实际每张预测图的总预测信息放在detect_info字典中的info_count属性中，而info_count作为存储总预测信息的数据则也是一个字典。我们先查找出全部属于该图片集的预测数据，接着将每个图的info_count字典取出放在一个列表中，最后将整个列表的属性和值对应相加获得一个新列表，转为json的形式再传如html即可在js中使用。把属性与值分别放在两个列表中，就能够通过他们使用echarts来绘制总数据的柱状图。

2.  更新监测图片时写入数据库的信息

   - 图片地址：从绝对路径改成相对路径，方便再html中直接与/media/进行叠加获取路径

   - 图片监测所得数据信息：原先只保存了一个信息，现改为以下

     ```py
     {
         'info_count':
         {
             '物品1': 数量,
             '物品2': 数量,
         },
         'info_list':
         [
             {'name': 物品名, 'xyxy': [x1,x2,x3,x4]},
             {'name': 物品名, 'xyxy': [x1,x2,x3,x4]},
             {'name': 物品名, 'xyxy': [x1,x2,x3,x4]},
             {'name': 物品名, 'xyxy': [x1,x2,x3,x4]},
             ...
         ]
     }
     ```

     